module juptune.data.json.parser;

import juptune.core.util : Result;

/// A `Result` error enum.
enum JsonParserError
{
    none,

    wrongDepth,                 /// Attempted to end an array or object when the depth buffer is either empty, or is for the opposite type of depth.
    tooDeep,                    /// Attempted to start reading an object or array, but the depth buffer has been completely used up.
    numberIsNegative,           /// Attempted to parse a negative number as an unsigned type.
    numberCannotBeRepresented,  /// Attempted to parse a number that cannot be represented with a specific native numeric type.
    unterminatedString,         /// A string/name is unterminated.
    extraComma,                 /// The final field in an array or object has a comma after it (believe it or not strict JSON parsing forbids this :/).
    missingColon,               /// Expected a colon between an object field name and its value.
    missingComma,               /// Expected a comma while reading next non-initial object name or array value. 
    invalidNumber,              /// There was some sort of syntax error when parsing a numeric value.
    invalidKeyword,             /// A keyword (unquoted text) wasn't recognised.
    invalidEscapeCharacter,     /// An invalid escape character was found within a string/name.
    unexpectedCharacter,        /// Could not determine what the next token should be, because the next character is not a known start-of-token character.
    eof,                        /// No more characters to consume.
    incomplete,                 /// Attempted to call `JsonParser.finish` while still midway through parsing.
}

/++
 + A zero-copy, zero-allocation lexer for parsing in-memory JSON input into tokens.
 +
 + Notes:
 +  This is a low-level interface that a higher-level deserialiser/DOM can be built on top off, this generally
 +  isn't the most comfortable thing to use.
 +
 +  **All slices produced by this parser are taken from the input, so all lifetimes are directly tied to the input slice's lifetime.**
 +
 +  While floating point numbers are parsed... you can't really access them yet since Juptune lacks string<->float conversion.
 +
 +  Similarly to `JsonBuilder` there is absolutely no support for UTF16 surrogate characters.
 +
 +  This is a strict parser, trailing commas aren't allowed (and other nicities like comments aren't supported).
 +
 + Depth:
 +  This struct does not allocate memory, so in order to keep track of whether the parser is inside
 +  an object or array, the caller must provide a depth buffer.
 +
 +  Each byte in the buffer allows for 8 levels of depth, so an 8 byte buffer would allow for a max of 64 levels of nesting.
 +
 + Usage:
 +  `JsonParser.next` should be called until the caller has finished reading in its root value. e.g.
 +   if the root value is an array, then it should know which `arrayEnd` token finishes it off.
 +
 +  Once the caller (thinks) has finished reading data, it should call `JsonParser.finish` so the parser can confirm there's
 +  nothing left to read.
 +
 +  `JsonParser.next` provides an example of what its output for a given input looks like.
 + ++/
struct JsonParser
{
    import std.traits : isIntegral, isSigned;

    import juptune.data.alphabet : AsciiAlphabet;

    private static immutable Whitespace = AsciiAlphabet!" \t\n\r"();

    /// A token generated by `JsonParser.next` - ALL character slices are from the original input.
    static struct Token
    {
        /// What this token represents.
        enum Type
        {
            FAILSAFE,
            objectStart,    /// "{"
            objectEnd,      /// "}"
            arrayStart,     /// "["
            arrayEnd,       /// "]"
            name,           /// Given `{"name": "value", "foo": "bar"}`, this token is for "name" and "foo"
            boolean,        /// `true` or `false`
            null_,          /// `null`
            integer,        /// 123 or -123
            floating,       /// [-]1.2, [-]1.2e3, [-]1.2e+3, [-]1.2e-3
            string,         /// "value"
        }

        private static struct String
        {
            const(char)[] textNoQuotes;
            bool hasEscapeChars;
        }

        private static struct Boolean
        {
            bool value;
        }

        private static struct Integer
        {
            bool couldBeRepresented;
            bool isSigned;

            union
            {
                ulong asUnsigned;
                long asSigned;
            }
        }

        private static struct Floating
        {
            // TODO: string -> float support
            Integer integerPart;
            const(char)[] decimalPart;
            const(char)[] exponentPart;
        }

        private union Inner
        {
            String asString;
            Boolean asBoolean;
            Integer asInteger;
            Floating asFloating;
        }

        Type type;
        const(char)[] rawText; /// The whole raw text of this token, e.g. for strings this includes the start and end quotes.
        private Inner _inner;

        private this(Type type) @nogc nothrow pure
        in(type != Type.FAILSAFE, "bug: FAILSAFE")
        {
            this.type = type;

            switch(type) with(Type)
            {
                case objectStart: this.rawText = "{"; break;
                case objectEnd: this.rawText = "}"; break;
                case arrayStart: this.rawText = "["; break;
                case arrayEnd: this.rawText = "]"; break;
                case null_: this.rawText = "null"; break;

                default: assert(false, "bug: this constructor shouldn't have been called with the given type");
            }
        }

        private this(bool value) @nogc nothrow pure
        {
            this.rawText = (value) ? "true" : "false";
            this.type = Type.boolean;
            this._inner.asBoolean.value = value;
        }

        private this(const(char)[] value, bool hasEscapeChars, bool isName) @nogc nothrow pure
        {
            this.rawText = value;
            this._inner.asString.hasEscapeChars = hasEscapeChars;
            this._inner.asString.textNoQuotes = value[1..$-1]; // Remove quotes

            if(isName)
                this.type = Type.name;
            else
                this.type = Type.string;
        }

        private this(const(char)[] raw, Integer value) @nogc nothrow pure
        {
            this.rawText = raw;
            this.type = Type.integer;
            this._inner.asInteger = value;
        }

        private this(const(char)[] raw, Floating value) @nogc nothrow pure
        {
            this.rawText = raw;
            this.type = Type.floating;
            this._inner.asFloating = value;
        }

        /++
         + Whether this string/name token has escape characters within it. This can
         + be used to avoid needless allocations in certain use cases (rather than always trying to escape the string).
         +
         + Returns:
         +  `true` if there's escape characters within the string, `false` otherwise.
         + ++/
        bool hasEscapeChars() @trusted @nogc nothrow pure const
        in(this.type == Type.string || this.type == Type.name, "this token isn't for a string or name")
        {
            return this._inner.asString.hasEscapeChars;
        }

        /++
         + Retrieves the string value of this string/name token (without the start and end quotes).
         +
         + Notes:
         +  This value MAY contain unescaped escape sequences (as JsonParser doesn't allocate), this can be detected
         +  with `hasEscapeChars`. Please use `asEscapedString` to lazily decode the string.
         +
         + Returns:
         +  The unescaped value of this string/name token.
         + ++/
        const(char)[] asUnescapedString() @trusted @nogc nothrow pure const
        in(this.type == Type.string || this.type == Type.name, "this token isn't for a string or name")
        {
            return this._inner.asString.textNoQuotes;
        }

        /++
         + Retrieves the value of this boolean token.
         + ++/
        bool asBool() @trusted @nogc nothrow pure const
        in(this.type == Type.boolean, "this token isn't for a bool")
        {
            return this._inner.asBoolean.value;
        }

        /++
         + Retrieves the value of this integer token, and attempts to coerce it into the given `IntegralT`.
         +
         + Notes:
         +  This function only works on integer tokens. Floats must either use `asFloat` (TODO) or `asNumber` (TODO).
         +
         +  The value of `number` is undefined if this function returns an error.
         +
         + Params:
         +  number = The resulting int.
         +
         + Throws:
         +  `JsonParserError.numberCannotBeRepresented` if the number was too big or too small to fit into any native integer type.
         +
         +  `JsonParserError.numberCannotBeRepresented` if the number stored _can_ be represented by a native integer type, but not by the specified `IntegralT`.
         +
         +  `JsonParserError.numberIsNegative` if `IntegralT` is unsigned, but the number stored is negative.
         +
         + Returns:
         +  An errorful `Result` if something went wrong.
         + ++/
        Result asInt(IntegralT)(scope out IntegralT number) @trusted @nogc nothrow
        if(isIntegral!IntegralT)
        in(this.type == Type.integer, "this token isn't for an integer or float")
        {
            const inner = this._inner.asInteger;

            if(!inner.couldBeRepresented)
                return Result.make(JsonParserError.numberCannotBeRepresented, "this token contains an integer that cannot be represented as any native integral type (it's too big or small)"); // @suppress(dscanner.style.long_line)

            if(inner.isSigned)
            {
                static if(!isSigned!IntegralT)
                {
                    if(inner.asSigned < 0)
                        return Result.make(JsonParserError.numberIsNegative, "this token contains a negative integer, so cannot be represented as unsigned type "~IntegralT.stringof); // @suppress(dscanner.style.long_line)
                }

                if(inner.asSigned < IntegralT.min || inner.asSigned > IntegralT.max)
                    return Result.make(JsonParserError.numberCannotBeRepresented, "this token contains a signed integer that cannot be represented as type "~IntegralT.stringof~" (it's too big or small)"); // @suppress(dscanner.style.long_line)

                number = cast(IntegralT)inner.asSigned;
            }
            else
            {
                if(inner.asUnsigned > IntegralT.max)
                    return Result.make(JsonParserError.numberCannotBeRepresented, "this token contains an unsigned integer that cannot be represented as type "~IntegralT.stringof~" (it's too big)"); // @suppress(dscanner.style.long_line)

                number = cast(IntegralT)inner.asUnsigned;
            }

            return Result.noError;
        }

        /// Similar to `asInt`, but will fail an assert if conversion wasn't possible.
        IntegralT mustAsInt(IntegralT)()
        {
            import juptune.core.util : resultAssert;
            
            IntegralT number;
            this.asInt!IntegralT(number).resultAssert;
            return number;
        }
    }

    private
    {   
        enum BITS_PER_BYTE = 8;

        const(ubyte)[]  _input; // The input will likely be from an external source, and probably hasn't been verified as valid UTF8 yet, hence const(ubyte) over const(char)
        size_t          _cursor;
        ubyte[]         _depthMarkers; // Each bit represents whether the depth was created by an object (0) or array (1)
        size_t          _depth;
        bool            _rootValueHasBeenParsed;
        bool            _isFirstValueInDepth;
        bool            _expectingName;
        Token.Type      _previousType;

        debug invariant
        {
            if(this._expectingName)
                assert(this.inObject(), "bug: _expectingName shouldn't be true when we're not in an object?");
        }
    }

    /++
     + Constructs a new JsonParser that will parse the given `input`.
     +
     + Params:
     +  input           = The input to parse.
     +  depthMarkers    = The depth buffer (see main comment for JsonParser).
     + ++/
    this(const(ubyte)[] input, ubyte[] depthMarkers) @nogc nothrow
    in(depthMarkers.length > 0, "depthMarkers is empty - please provide at least 1 marker byte")
    {
        this._input = input;
        this._depthMarkers = depthMarkers;
    }

    /// ditto.
    this(const(char)[] input, ubyte[] depthMarkers) @nogc nothrow
    {
        this(cast(ubyte[])input, depthMarkers);
    }

    /++
     + Checks whether the depth buffer is empty (i.e. we're not currently inside an array or object), and that
     + the root-level value has been parsed.
     +
     + Throws:
     +  `JsonBuilderError.incomplete` if the depth buffer isn't empty, indicating an unterminated object or array, or
     +  the caller has tried to stop parsing early for some reason.
     +
     + Returns:
     +  A `Result` indicating whether the parser can be considered "finished" or not.
     + ++/
    Result finish()
    {
        if(this._depth != 0)
            return Result.make(JsonParserError.incomplete, "depth buffer isn't empty, cannot finish mid-way through");
        return Result.noError;
    }

    /++
     + Parses the next token from the input.
     +
     + Notes:
     +  The lifetime of the token's data is directly tied to the input slice's lifetime.
     +
     + Output Example:
     +  Given the following input
     +
     +  ```json
     +  {
     +      "array": [1, true],
     +      "null": null,
     +      "subobj": {
     +          "false": false,
     +          "int": 213,
     +          "float": 1.23,
     +          "str": "string",
     +          "str2": "escaped\n",
     +      }
     +  }
     +  ```
     +
     +  The following tokens are generated (using enum `JsonParser.Token.Type`)
     +
     +  ```txt
     +  objectStart
     +      name ("array")
     +      arrayStart
     +          integer (1)
     +          boolean (true)
     +      arrayEnd
     +
     +      name ("null")
     +      null
     +
     +      name ("subobj")
     +      objectStart
     +          name ("false")
     +          boolean (false)
     +
     +          name ("int")
     +          integer (213)
     +
     +          name ("float")
     +          floating (1.23)
     +
     +          name ("str")
     +          string ("string", hasEscapeChars: false)
     +
     +          name ("str2")
     +          string ("escaped\\n", hasEscapeChars: true)
     +      objectEnd
     +  objectEnd
     +  ```
     +
     + Params:
     +  token = The resulting token.
     +
     + Throws:
     +  `JsonParserError.eof` under various conditions, such as the input being empty, or an object/array being unterminated.
     +
     +  `JsonParserError.missingComma` if there's a comma missing between values within an object/array.
     +
     +  `JsonParserError.missingColon` if there's a colon missing between an object's field's name and its value.
     +
     +  `JsonParserError.extraComma` if the final item within an object/array has a comma after it.
     +
     +  `JsonParserError.unexpectedCharacter` under various conditions, namely when this function cannot determine what the next token should be.
     +
     +  `JsonParserError.invalidNumber` if an integer/floating value is invalid (for various reasons).
     +
     +  `JsonParserError.unterminatedString` if a string is unterminated.
     +
     +  `JsonParserError.tooDeep` if the depth buffer is exceeded.
     +
     +  `JsonParserError.wrongDepth` if there's an `objectEnd` is found when an `arrayEnd` was expected (or vice-versa).
     +
     +  `JsonParserError.invalidKeyword` if "true", "false", or "null" was expected but something else was there (e.g. a typo like "nul").
     +
     + Returns:
     +  An errorful `Result` if something went wrong.
     + ++/
    Result next(scope out Token token) @nogc nothrow
    in(!this._rootValueHasBeenParsed, "bug: the root value for the given input has already been parsed - the caller shouldn't be attempting to read anything else") // @suppress(dscanner.style.long_line)
    {
        import juptune.core.ds : String2;

        scope(exit) this._previousType = token.type;

        this.skipWhite();
        if(this.isEof)
            return Result.make(JsonParserError.eof, "no more characters to consume (probably missing closing brackets somewhere)"); // @suppress(dscanner.style.long_line)

        const earlyCh = this.peek();

        bool hadComma = false;
        if(this._depth > 0 && earlyCh != '}' && earlyCh != ']' && this._previousType != Token.Type.name)
        {
            if(!this._isFirstValueInDepth)
            {
                const comma = this.nom();
                if(comma != ',')
                {
                    return Result.make(
                        JsonParserError.missingComma, 
                        "expected comma when reading next object name or array value", 
                        String2("got '", comma, "' (cast(ubyte)", cast(ubyte)comma, ")")
                    );
                }
                this.skipWhite();
                if(this.isEof)
                    return Result.make(JsonParserError.eof, "no more characters to consume (probably missing closing brackets somewhere)"); // @suppress(dscanner.style.long_line)
                hadComma = true;
            }
            this._isFirstValueInDepth = false;
        }

        if(this._expectingName && earlyCh != '}')
        {
            const(char)[] text;
            bool hasEscapeChars;
            auto result = this.nextString(text, hasEscapeChars);
            if(result.isError)
                return result;

            this.skipWhite();
            if(this.isEof)
                return Result.make(JsonParserError.missingColon, "expected colon after object field name, but ran out of bytes"); // @suppress(dscanner.style.long_line)
            
            const colon = this.nom();
            if(colon != ':')
            {
                return Result.make(
                    JsonParserError.missingColon, 
                    "expected colon after object field", 
                    String2("got '", colon, "' (cast(ubyte)", cast(ubyte)colon, ")")
                );
            }

            token = Token(text, hasEscapeChars, isName: true);
            this._expectingName = false;
            return Result.noError;
        }

        // Takes affect on the next call to next() for after we read in the current name's value (who's name was read in the previous call to next()).
        scope(exit) if(this.inObject)
            this._expectingName = true;

        const ch = this.peek();
        switch(ch)
        {
            case '{':
                this.nom();
                token = Token(Token.Type.objectStart);
                this._isFirstValueInDepth = true;
                this._expectingName = true;
                return this.pushDepth!true();
            case '}':
                this.nom();
                token = Token(Token.Type.objectEnd);
                this._isFirstValueInDepth = false;
                this._expectingName = false;

                if(hadComma)
                    return Result.make(JsonParserError.extraComma, "extra comma before ending object");
                return this.popDepth!true();
            case '[':
                this.nom();
                token = Token(Token.Type.arrayStart);
                this._isFirstValueInDepth = true;
                return this.pushDepth!false();
            case ']':
                this.nom();
                token = Token(Token.Type.arrayEnd);
                this._isFirstValueInDepth = false;
                if(hadComma)
                    return Result.make(JsonParserError.extraComma, "extra comma before ending array");
                return this.popDepth!false();
            case 't':
                if(this._depth == 0)
                    this._rootValueHasBeenParsed = true;
                token = Token(true);
                return this.expectKeyword!"true"();
            case 'f':
                if(this._depth == 0)
                    this._rootValueHasBeenParsed = true;
                token = Token(false);
                return this.expectKeyword!"false"();
            case 'n':
                if(this._depth == 0)
                    this._rootValueHasBeenParsed = true;
                token = Token(Token.Type.null_);
                return this.expectKeyword!"null"();
            case '"':
                if(this._depth == 0)
                    this._rootValueHasBeenParsed = true;

                const(char)[] text;
                bool hasEscapeChars;
                auto result = this.nextString(text, hasEscapeChars);
                if(!result.isError)
                    token = Token(text, hasEscapeChars, isName: false);

                return result;
            case '-':
            case '0': .. case '9':
                if(this._depth == 0)
                    this._rootValueHasBeenParsed = true;

                const(char)[] rawText;
                Token.Integer integer;
                Token.Floating floating;
                bool isFloating;
                auto result = this.nextNumber(integer, floating, isFloating, rawText);
                if(!result.isError)
                {
                    if(isFloating)
                        token = Token(rawText, floating);
                    else
                        token = Token(rawText, integer);
                }

                return result;

            default:
                return Result.make(
                    JsonParserError.unexpectedCharacter, 
                    "unexpected character found when parsing next token",
                    String2("got '", ch, "' (cast(ubyte)", cast(ubyte)ch, ")")
                );
        }
    }

    private void skipWhite() @nogc nothrow
    {
        while(!this.isEof && Whitespace.isAllowed(this.peek()))
            this._cursor++;
    }

    private Result nextNumber(
        scope out Token.Integer integer, 
        scope out Token.Floating floating,
        scope out bool isFloating,
        scope out const(char)[] rawText,
    ) @nogc nothrow
    {
        import std.ascii : isDigit, toLower;
        import juptune.core.util : fromBase10;

        const start = this._cursor;
        const isNegative = (this.peek() == '-');
        if(isNegative)
            this.nom();

        const(char)[] nomAllDigits()
        {
            const partStart = this._cursor;
            while(!this.isEof)
            {
                const ch = this.nom(); // Keep nomming digits
                if(!ch.isDigit)
                {
                    this.backOne();
                    break;
                }
            }

            return cast(const(char)[])this._input[partStart..this._cursor];
        }

        // First read the integer part, since that'll always exist
        const integerPart = nomAllDigits();
        if(integerPart.length == 0)
            return Result.make(JsonParserError.invalidNumber, "number lacks digits");

        string errorMsg;
        if(isNegative)
        {
            integer.asSigned = -fromBase10!long(integerPart, errorMsg);
            integer.isSigned = true;
        }
        else
            integer.asUnsigned = fromBase10!ulong(integerPart, errorMsg);
        integer.couldBeRepresented = (errorMsg.length == 0);

        // Start reading the decimal part if one exists
        if(!this.isEof && this.peek() == '.')
        {
            isFloating = true;
            floating.integerPart = integer;

            this.nom(); // Nom the decimal place
            const decimalPart = nomAllDigits();
            if(decimalPart.length == 0)
                return Result.make(JsonParserError.invalidNumber, "number lacks any digits after decimal place");
            floating.decimalPart = decimalPart;

            // Likewise for the exponent
            if(!this.isEof && this.peek().toLower == 'e')
            {
                this.nom(); // Nom the E

                // TODO: Handle properly once we can convert strings to floats
                if(!this.isEof && (this.peek() == '+' || this.peek() == '-'))
                    this.nom();

                const exponentPart = nomAllDigits();
                if(exponentPart.length == 0)
                    return Result.make(JsonParserError.invalidNumber, "number lacks any digits after exponent marker");
                floating.exponentPart = exponentPart;
            }
        }

        rawText = cast(const(char)[])this._input[start..this._cursor];
        return Result.noError;
    }

    private Result nextString(out const(char)[] textWithQuotes, out bool hasEscapeChars) @nogc nothrow
    {
        import juptune.core.ds   : String2;
        import juptune.data.utf8 : utf8Validate;

        const start = this._cursor;
        const firstQuote = this.nom();
        if(firstQuote != '"')
        {
            return Result.make(
                JsonParserError.unexpectedCharacter, 
                "expected quote to start off string/name",
                String2("got '", firstQuote, "' (cast(ubyte)", cast(ubyte)firstQuote, ")")
            );
        }

        while(true)
        {
            if(this.isEof)
                return Result.make(JsonParserError.unterminatedString, "string/name is unterminated");

            const ch = this.nom();
            if(ch == '"')
            {
                textWithQuotes = cast(const(char)[])this._input[start..this._cursor];
                break;
            }

            if(ch != '\\')
                continue;
            if(this.isEof)
                return Result.make(JsonParserError.unterminatedString, "string/name is unterminated");
            hasEscapeChars = true;

            const escape = this.nom();
            switch(escape)
            {
                case '"':
                case '\\':
                case '/':
                case 'b':
                case 'f':
                case 'n':
                case 'r':
                case 't': 
                    break;
                
                default:
                    return Result.make(
                        JsonParserError.invalidEscapeCharacter, 
                        "invalid escape character found within string/name"
                    );
            }
        }

        return utf8Validate(textWithQuotes);
    }

    private Result pushDepth(bool isObject)() @nogc nothrow
    {
        static if(isObject)
            enum DebugName = "object";
        else
            enum DebugName = "array";

        if(this._depth >= this._depthMarkers.length * BITS_PER_BYTE)
            return Result.make(JsonParserError.tooDeep, "Attempted to start reading an "~DebugName~", with a full depth buffer."); // @suppress(dscanner.style.long_line)

        const byteIndex = this._depth / 8;
        const bitIndex = this._depth % 8;
        static if(isObject)
            this._depthMarkers[byteIndex] &= ~(1 << bitIndex);
        else
            this._depthMarkers[byteIndex] |= (1 << bitIndex);
        this._depth++;
        return Result.noError;
    }

    private Result popDepth(bool isObject)() @nogc nothrow
    {
        static if(isObject)
            enum DebugName = "object";
        else
            enum DebugName = "array";

        if(this._depth == 0)
            return Result.make(JsonParserError.wrongDepth, "Attempted to end an "~DebugName~", with an empty depth buffer."); // @suppress(dscanner.style.long_line)

        static if(isObject)
        {
            if(this.inArray())
                return Result.make(JsonParserError.wrongDepth, "Attempted to end an object, while the current depth is an array."); // @suppress(dscanner.style.long_line)
        }
        else
        {
            if(this.inObject())
                return Result.make(JsonParserError.wrongDepth, "Attempted to end an array, while the current depth is an object."); // @suppress(dscanner.style.long_line)
        }
        this._depth--;

        if(this._depth == 0)
            this._rootValueHasBeenParsed = true;
        return Result.noError;
    }

    private bool inObject() @nogc nothrow const
    {
        if(this._depth == 0)
            return false;

        const byteIndex = (this._depth - 1) / 8;
        const bitIndex = (this._depth - 1) % 8;
        return (this._depthMarkers[byteIndex] & (1 << bitIndex)) == 0;
    }

    private bool inArray() @nogc nothrow const
    {
        if(this._depth == 0)
            return false;

        const byteIndex = (this._depth - 1) / 8;
        const bitIndex = (this._depth - 1) % 8;
        return (this._depthMarkers[byteIndex] & (1 << bitIndex)) != 0;
    }

    private bool isEof() @nogc nothrow const
    {
        return this._cursor >= this._input.length;
    }

    private char peek() @nogc nothrow const
    in(!this.isEof, "bug: EOF - please use isEof")
    {
        return this._input[this._cursor];
    }

    private char nom() @nogc nothrow
    in(!this.isEof, "bug: EOF - please use isEof")
    {
        return this._input[this._cursor++];
    }

    private void backOne() @nogc nothrow
    {
        this._cursor--;
    }

    private Result expectKeyword(string Keyword)() @nogc nothrow
    {
        import juptune.core.ds : String2;

        if(this._cursor + Keyword.length > this._input.length)
            return Result.make(JsonParserError.invalidKeyword, "ran out of bytes when expecting keyword `"~Keyword~"`");

        const slice = this._input[this._cursor..this._cursor+Keyword.length];
        if(slice != Keyword)
        {
            return Result.make(
                JsonParserError.invalidKeyword, 
                "expected keyword `"~Keyword~"`", 
                String2("got '", slice, "'")
            );
        }

        this._cursor += Keyword.length;
        return Result.noError;
    }
}

/++ Unittests ++/

@("JsonParser - passing single-token cases")
unittest
{
    import std.format : format;

    import juptune.core.util : resultAssert;

    alias tt = JsonParser.Token.Type;

    static struct T
    {
        string input;
        tt expectedType;
        void function(JsonParser.Token) validate;
    }

    auto cases = [
        "true": T("true", tt.boolean, (t) { assert(t.asBool); }),
        "false": T("false", tt.boolean, (t) { assert(!t.asBool); }),
        "null": T("null", tt.null_, (t){}),
        "{": T("{", tt.objectStart, (t){}),
        "[": T("[", tt.arrayStart, (t){}),

        "empty string": T(`""`, tt.string, (t){ assert(t.asUnescapedString == ""); }),
        "basic string": T(`"abc123"`, tt.string, (t){ assert(t.asUnescapedString == "abc123"); }),
        "utf8 string": T(`"こんにちは"`, tt.string, (t){ assert(t.asUnescapedString == "こんにちは"); }),
        "escape string": T(`"\"\\\/\b\f\n\r\t"`, tt.string, (t){ assert(t.asUnescapedString == `\"\\\/\b\f\n\r\t`); }),

        "number - single digit": T("1", tt.integer, (t){ assert(t.mustAsInt!int == 1); }),
        "number - multiple digits": T("12345", tt.integer, (t){ assert(t.mustAsInt!int == 12_345); }),
        "number - negative": T("-123", tt.integer, (t){ assert(t.mustAsInt!int == -123); }),
        "number - decimal": T("1.12", tt.floating, (t){ /*TODO*/ }),
        "number - exponent": T("1.12e1", tt.floating, (t){ /*TODO*/ }),
        "number - Exponent": T("1.12E1", tt.floating, (t){ /*TODO*/ }),
        "number - exponent +": T("1.12e+1", tt.floating, (t){ /*TODO*/ }),
        "number - exponent -": T("1.12e-1", tt.floating, (t){ /*TODO*/ }),
    ];

    foreach(name, test; cases)
    {
        try
        {
            auto parser = JsonParser(test.input, new ubyte[1]);
            
            JsonParser.Token token;
            parser.next(token).resultAssert;

            assert(test.expectedType == token.type, format("expected type %s but got %s", test.expectedType, token.type)); // @suppress(dscanner.style.long_line)
            assert(token.rawText == test.input, format("got rawText of '%s' but wanted '%s'", token.rawText, test.input)); // @suppress(dscanner.style.long_line)
            test.validate(token);

            if(token.type != tt.objectStart && token.type != tt.arrayStart)
                assert(parser._rootValueHasBeenParsed, "_rootValueHasBeenParsed wasn't set");
        }
        catch(Throwable err) // @suppress(dscanner.suspicious.catch_em_all)
            assert(false, "\n["~name~"]: "~err.msg);
    }
}

@("JsonParser - failing single-token cases")
unittest
{
    import std.format : format;

    import juptune.core.util : resultAssertSameCode;

    static struct T
    {
        string input;
        JsonParserError expectedError;
    }

    auto cases = [
        "no depth - object": T("}", JsonParserError.wrongDepth),
        "no depth - array": T("]", JsonParserError.wrongDepth),
        "unterminated string": T(`"`, JsonParserError.unterminatedString),
        "unterminated string - escape edge case": T(`"\`, JsonParserError.unterminatedString),
        "unterminated string - escape edge case 2": T(`"\"`, JsonParserError.unterminatedString),
        "true": T("t", JsonParserError.invalidKeyword),
        "false": T("f", JsonParserError.invalidKeyword),
        "null": T("n", JsonParserError.invalidKeyword),
        "eof": T("", JsonParserError.eof),
        "number - no digits - negative case": T("-", JsonParserError.invalidNumber),
        "number - no digits - decimal case": T("1.", JsonParserError.invalidNumber),
        "number - no digits - exponent case": T("1.1e", JsonParserError.invalidNumber),
        "unexpected token-initial character": T("_", JsonParserError.unexpectedCharacter),
    ];

    foreach(name, test; cases)
    {
        try
        {
            auto parser = JsonParser(test.input, new ubyte[1]);
            
            JsonParser.Token token;
            auto result = parser.next(token);
            resultAssertSameCode!JsonParserError(result, Result.make(test.expectedError));
        }
        catch(Throwable err) // @suppress(dscanner.suspicious.catch_em_all)
            assert(false, "\n["~name~"]: "~err.msg);
    }
}

@("JsonParser - passing multi-token cases")
unittest
{
    import std.algorithm : map, equal;
    import std.format : format;

    import juptune.core.util : resultAssert;

    alias tt = JsonParser.Token.Type;

    static struct T
    {
        string input;
        tt[] expectedTokens;
    }

    auto cases = [
        "empty object": T("{}", [tt.objectStart, tt.objectEnd]),
        "empty array": T("[]", [tt.arrayStart, tt.arrayEnd]),

        "array - single value": T("[true]", [tt.arrayStart, tt.boolean, tt.arrayEnd]),
        "array - multi value": T("[true, false]", [tt.arrayStart, tt.boolean, tt.boolean, tt.arrayEnd]),

        "object - single value": T(`{"foo":"bar"}`, [tt.objectStart, tt.name, tt.string, tt.objectEnd]),
        "object - multi value": T(`{"foo":"bar", "abc": true}`, [
            tt.objectStart, 
                tt.name, tt.string,
                tt.name, tt.boolean,
            tt.objectEnd
        ]),

        "nested 1": T(`[[{}, []], {"a": [{}], "b": {}}]`, [
            tt.arrayStart,
                tt.arrayStart,
                    tt.objectStart,
                    tt.objectEnd,
                    tt.arrayStart,
                    tt.arrayEnd,
                tt.arrayEnd,
                tt.objectStart,
                    tt.name,
                    tt.arrayStart,
                        tt.objectStart,
                        tt.objectEnd,
                    tt.arrayEnd,
                    tt.name,
                    tt.objectStart,
                    tt.objectEnd,
                tt.objectEnd,
            tt.arrayEnd,
        ])
    ];

    foreach(name, test; cases)
    {
        try
        {
            auto parser = JsonParser(test.input, new ubyte[1]);
            
            JsonParser.Token[] tokens;
            while(!parser._rootValueHasBeenParsed)
            {
                JsonParser.Token token;
                parser.next(token).resultAssert;
                tokens ~= token;
            }

            auto asTypes = tokens.map!(t => t.type);
            assert(asTypes.equal(test.expectedTokens), format("expected:\n\t%s\ngot:\n\t%s", test.expectedTokens, asTypes)); // @suppress(dscanner.style.long_line)
        }
        catch(Throwable err) // @suppress(dscanner.suspicious.catch_em_all)
            assert(false, "\n["~name~"]: "~err.msg);
    }
}

@("JsonParser - failing multi-token cases")
unittest
{
    import std.format : format;

    import juptune.core.util : resultAssertSameCode;

    static struct T
    {
        string input;
        JsonParserError expectedError;
    }

    auto cases = [
        "unterminated object": T("{", JsonParserError.eof),
        "unterminated array": T("[", JsonParserError.eof),
        "unexpected character - object, array": T("{]", JsonParserError.unexpectedCharacter), // idc
        "wrong depth - array, object": T("[}", JsonParserError.wrongDepth),
        "too deep": T("[[[[[[[[[", JsonParserError.tooDeep),
        
        "array - expected comma": T(`["a" "b"]`, JsonParserError.missingComma),
        "array - extra comma": T(`["a",]`, JsonParserError.extraComma),
        "array - empty with comma": T(`[,]`, JsonParserError.unexpectedCharacter),

        "object - expected comma": T(`{"a":true "b"}`, JsonParserError.missingComma),
        "object - extra comma": T(`{"a":true,}`, JsonParserError.unexpectedCharacter), // idc
        "object - empty with comma": T(`{,}`, JsonParserError.unexpectedCharacter),
        "object - missing colon": T(`{"a" true}`, JsonParserError.missingColon),
        "object - missing colon (eof)": T(`{"a" `, JsonParserError.missingColon),

        "eof - after depth comma": T(`[true,`, JsonParserError.eof),
    ];

    foreach(name, test; cases)
    {
        try
        {
            auto parser = JsonParser(test.input, new ubyte[1]);
            
            while(true)
            {
                JsonParser.Token token;
                auto result = parser.next(token);
                if(result.isError)
                {
                    resultAssertSameCode!JsonParserError(result, Result.make(test.expectedError));
                    break;
                }
            }
        }
        catch(Throwable err) // @suppress(dscanner.suspicious.catch_em_all)
            assert(false, "\n["~name~"]: "~err.msg);
    }
}